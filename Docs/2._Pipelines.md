# Pipelines

- The **heart of Quartz** is pipe-based composition.
- As a *simple sequence of steps*, the code becomes more readable.

``` qrtz
string := " HELLO WORLD "
string -> trim -> lower -> print
```

- Compare this to the Python equivalent:

```py
string = " HELLO WORLD "
print(string.strip().lower())
```

- With just three functions, you're already lost.
- In Quartz, there are no methods: only functions.
- No nested calls, no clutter.

## Implying the First Argument

- Each step receives the *value from the previous step* as input.

``` qrtz
a -> f         # f(a)
a -> f b       # f(a, b)

a -> f -> f b  # f(f(a), b)
```

- Functions like `append` can be used like so:

``` qrtz
append([], ".")
```

- But with pipelines, they can become easier to use and read.

``` qrtz
[] -> append "."
```

## I.B.1.a. Pipelines

- You can also bind a value using the `=>` pipeline operator.
  - This is especially helpful inside a pipeline.

``` qrtz
(
" HELLO WORLD "
-> trim
-> lower
:=> message  # message := "hello world"
-> print
)
```

## I.B.2.a. Shorthand

- To take the result of a pipeline and assign it to a variable...
  - If the variable comes first, `<-` comes before the name.
  - If it's in the middle or the end, use the explicit `assign` function.

``` qrtz
username <-> upper
// Same as...
username <- username >> upper

username 

" kendra "
>> upper
>> assign username  // Explicit `assign` function
// Same as...
username <- " kendra " >> upper

```

## I.B.2.b. O

- The usual math operators and more can be used in conjunction with `<-`.

``` qrtz
x = -1
x <- 0  // Basic
x +<- 1 // Same as x <- x + 1
```
